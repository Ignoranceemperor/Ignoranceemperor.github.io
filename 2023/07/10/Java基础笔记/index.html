<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>你好，朋友！</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Java基础笔记开始时间：2023年7月3日 介绍：本笔记用于记录学习Java八股文时的内容。每一个3级标题同JavaGuide的标题内容一致。">
<meta property="og:type" content="article">
<meta property="og:title" content="你好，朋友！">
<meta property="og:url" content="http://www.youngj.top/2023/07/10/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="你好，朋友！">
<meta property="og:description" content="Java基础笔记开始时间：2023年7月3日 介绍：本笔记用于记录学习Java八股文时的内容。每一个3级标题同JavaGuide的标题内容一致。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\YJ\AppData\Roaming\Typora\typora-user-images\image-20230703111902407.png">
<meta property="og:image" content="c:\Users\YJ\AppData\Roaming\Typora\typora-user-images\image-20230705165914703.png">
<meta property="og:image" content="c:\Users\YJ\AppData\Roaming\Typora\typora-user-images\image-20230708201729930.png">
<meta property="og:image" content="c:\Users\YJ\AppData\Roaming\Typora\typora-user-images\image-20230709113856239.png">
<meta property="article:published_time" content="2023-07-10T13:40:49.518Z">
<meta property="article:modified_time" content="2023-07-11T07:17:22.476Z">
<meta property="article:author" content="YoungJ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\YJ\AppData\Roaming\Typora\typora-user-images\image-20230703111902407.png">
  
    <link rel="alternate" href="/atom.xml" title="你好，朋友！" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">你好，朋友！</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.youngj.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java基础笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/10/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-07-10T13:40:49.518Z" itemprop="datePublished">2023-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java基础笔记"><a href="#Java基础笔记" class="headerlink" title="Java基础笔记"></a>Java基础笔记</h1><p>开始时间：2023年7月3日</p>
<p>介绍：本笔记用于记录学习Java八股文时的内容。每一个3级标题同JavaGuide的标题内容一致。</p>
<span id="more"></span>

<h3 id="Java基础常见面试题总结（上）"><a href="#Java基础常见面试题总结（上）" class="headerlink" title="Java基础常见面试题总结（上）"></a>Java基础常见面试题总结（上）</h3><ol>
<li><p>Java和C++的区别</p>
<p>Java和C++都是面向对象的语言，都支持封装、继承和多态。不同的是</p>
<ul>
<li>C++有指针，但是Java中没有指针，程序内存更安全</li>
<li>C++的类支持多继承，而Java的类只支持单继承，但是Java中的接口支持多继承</li>
<li>C++需要程序员手动释放内存，Java中有自动内存管理垃圾回收机制（GC）。</li>
<li>C++支持方法重载和操作符重载，Java只支持方法重载。（操作符重载增加了复杂性，与Java设计初衷不同）</li>
</ul>
</li>
<li><p>基本类型和包装类型的区别</p>
<p><img src="C:\Users\YJ\AppData\Roaming\Typora\typora-user-images\image-20230703111902407.png" alt="image-20230703111902407"></p>
<ul>
<li>用途：在定义常量和局部变量时，通常使用基本数据类型。在其他地方，如方法的参数，类属性中通常使用包装类型。包装类型是支持泛型的，而基本数据类型是不支持的。</li>
<li>存储方式：包装类型属于对象类型，几乎所有的对象类型都存在堆中。定义在方法内部的基本数据类型存在栈中的局部变量表，定义在类中的基本数据类型的成员变量存在堆中，这实际上取决于方法和对象的存储位置。</li>
<li>占用空间：</li>
<li>默认值：包装类型的默认值是null，基本数据类型的默认值不是null，如int的默认值是0。</li>
<li>比较方式：包装类型若使用 &#x3D;&#x3D; 进行比较，比较的则是对象的内存地址。基本数据类型 &#x3D;&#x3D; 比较的则是值。</li>
</ul>
</li>
<li><p>包装类型的缓存机制</p>
<ul>
<li><p>在Java的基本数据类型对应的包装类型中，部分包装类型使用缓存机制来提升性能。</p>
</li>
<li><p>实现方式是在类初始化的时，会提前创建好频繁使用的包装类对象，当需要使用某个包装类对象时，如果该包装对象的值在缓存的范围内，就返回缓存的对象，否则就创建新的对象并返回。</p>
</li>
<li><p>Byte，Short，Integer，Long这4种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据。</p>
</li>
<li><p>Character包装类创建了 **[0，127]**范围的缓存数据。</p>
</li>
<li><p>Boolean创建了 True 和 False。</p>
</li>
<li><p>浮点类型包装类 Float和Double并没有实现缓存机制。</p>
</li>
</ul>
</li>
<li><p>成员变量和局部变量的区别</p>
<p><img src="C:\Users\YJ\AppData\Roaming\Typora\typora-user-images\image-20230705165914703.png" alt="image-20230705165914703"></p>
<ul>
<li>语法形式：成员变量定义在类中，是属于类的。局部变量是定义在代码块或方法中的变量或者是方法的参数。成员变量是可以被访问控制符private、protected、public和static修饰的，而局部变量不可以（很明显，没有必要，因为局部变量是在方法调用期间被调用，肯定可以被该方法访问）。</li>
<li>存储方式：若成员变量被static修饰，则该变量是属于类的，被该类的所有实例对象共享。如果没有使用static修饰，则成员变量属于实例对象的。对象是存储于堆内存，局部变量是存储于栈内存。</li>
<li>生存时间：成员变量是对象的一部分，随着对象的创建而存在。局部变量是随着方法的调用而生成，随着方法的调用结束而消亡。</li>
<li>默认值：成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（final修饰的变量必须显示的赋初值），局部变量不会自动赋值。</li>
</ul>
</li>
<li><p>重载和重写有什么区别</p>
<ul>
<li><p>重载：重载是指在一个类中定义的同名方法，可以根据参数的不同（包括：参数类型、参数数量、参数顺序），做出不同的处理。</p>
</li>
<li><p>重写：子类继承父类方法时，参数一致，需要做出不同于父类方法的处理，需要对父类的方法内容进行重写。</p>
<ul>
<li><p>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。（两同两小一大）</p>
<ul>
<li><p>“两同”即方法名相同、形参列表相同；</p>
</li>
<li><p>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</p>
<ul>
<li><strong>说明：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</strong></li>
</ul>
</li>
<li><p>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</p>
</li>
</ul>
</li>
<li><p>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p>
</li>
<li><p>构造方法无法被重写</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Java基础常见面试题总结（中）"><a href="#Java基础常见面试题总结（中）" class="headerlink" title="Java基础常见面试题总结（中）"></a>Java基础常见面试题总结（中）</h3><ol>
<li><p>面向对象的三大特征</p>
<ul>
<li>封装：将一些属性封装在对象内部，不允许外部对象直接访问对象的内部信息，但是可以提供一些方法来供外部对象对对象内部的属性进行操作，如 setter 和 getter方法。</li>
<li>继承：可以将多个对象共同的属性封装成类，通过继承可以快速地创建新的类，提高代码的复用性。<ul>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ul>
</li>
<li>多态：顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。比如，小猫花花既是一只猫又是一直动物。<ul>
<li>多态的特点：<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li><strong>多态不能调用“只在子类存在但在父类不存在”的方法；</strong></li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>引用拷贝、浅拷贝、深拷贝</p>
<p><img src="C:\Users\YJ\AppData\Roaming\Typora\typora-user-images\image-20230708201729930.png" alt="image-20230708201729930"></p>
<ul>
<li>引用拷贝：引用拷贝是指两个不同的引用指向同一个对象。</li>
<li>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。也就是说，浅拷贝只会在堆内存中新建要拷贝的对象，对于对象内部的对象不会新建，而是副本和原对象共用内部的对象。</li>
<li>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。也就是说，深拷贝会在堆内存中将所有涉及的对象都重新创建一遍。</li>
</ul>
</li>
<li><p>hashcode()和equals()的关系，可以从以下两种情况来理解</p>
<ul>
<li>第一种：不会创建类对应的散列表，即不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。<ul>
<li>在这种情况下基本上不会用到类的hashcode()方法</li>
</ul>
</li>
<li>第二种：会创建类对应的散列表，会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，会创建该类的HashSet集合。<ul>
<li>在这种情况下，hashcode()和equals()是有关系的。以HashSet为例，HashSet中不允许有重复元素，那么当我们往HashSet中添加元素时，首先会计算要添加元素的hash值，找到其要添加的位置，若hash值与HashSet内已有元素相同，接下来会使用equals()方法进行比较，若相同，则该元素已存在，否则会利用一些处理hash冲突的方法（如拉链法，开放寻址法等）找到该元素存放的位置。若只重写equals()方法，不重写hashcode()方法，则equals()比较相同的元素，会因为hash值不同，而在HashSet中同时存在。</li>
</ul>
</li>
</ul>
</li>
<li><p>String、StringBuffer、StringBuilder的区别</p>
<ul>
<li>可变性：</li>
<li>线程安全：</li>
<li><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</li>
<li>性能：每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li>
<li>对于三者使用总结：<ul>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ul>
</li>
<li>String不可变的原因<ul>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个数组的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串常量池</p>
</li>
</ol>
<h3 id="Java基础常见面试题总结（下）"><a href="#Java基础常见面试题总结（下）" class="headerlink" title="Java基础常见面试题总结（下）"></a>Java基础常见面试题总结（下）</h3><ol>
<li>try、catch、finally如何使用<ul>
<li><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><code>catch</code>块：用于处理 try 捕获到的异常。</li>
<li><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。<strong>当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</strong></li>
<li>注意：<strong>不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</li>
</ul>
</li>
</ol>
<h3 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h3><ol>
<li><p>Java值传递详解</p>
<ul>
<li>形参和实参<ul>
<li>形参：用于<strong>定义</strong>函数&#x2F;方法，接收实参，不需要有确定的值。</li>
<li>实参：用于<strong>传递</strong>给函数&#x2F;方法的参数，必须有确定的值。</li>
</ul>
</li>
<li>值传递和引用传递<ul>
<li>值传递：方法接收的是实参值的拷贝，会创建副本。</li>
<li>引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>
<li><strong>Java中只有值传递</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>Java序列化详解</p>
<p>序列化：将数据结构或者对象转换成二进制字节流的过程</p>
<p>反序列化：将序列化后的二进制字节流转换成数据结构或者对象的过程</p>
<ul>
<li>序列化和反序列化常见的应用场景<ul>
<li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>
<li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>
<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>
<li><strong>综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></li>
</ul>
</li>
<li>对于不想序列化的字段可以使用transient进行修饰。<ul>
<li>transient只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul>
</li>
<li>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</li>
</ul>
</li>
<li><p>Java代理模式详解</p>
</li>
</ol>
<h3 id="Java集合常见面试题总结（上）"><a href="#Java集合常见面试题总结（上）" class="headerlink" title="Java集合常见面试题总结（上）"></a>Java集合常见面试题总结（上）</h3><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <strong><code>Collection</code>接口</strong>，主要用于<strong>存放单一元素</strong>；另一个是 <strong><code>Map</code> 接口</strong>，主要用于<strong>存放键值对</strong>。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。对于Map接口，下面又有HashMap、HashTable、SortedMap。</p>
<p><img src="C:\Users\YJ\AppData\Roaming\Typora\typora-user-images\image-20230709113856239.png" alt="image-20230709113856239"></p>
<ol>
<li><p>List、Set、Queue、Map四者的区别</p>
<ul>
<li>List：存储的元素是有序的，可重复的。</li>
<li>Set：存储的元素是无序的，不可重复的。</li>
<li>Queue：存储的元素是有序的，可重复的。</li>
<li>Map：key是无序的，不可重复的；value是无序的，可以重复的。每个键最多映射到一个值。</li>
</ul>
</li>
<li><p>ArrayList和Array（数组）的区别</p>
<ul>
<li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li>
<li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li>
<li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li>
<li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li>
<li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li>
</ul>
</li>
<li><p>ArrayList 插入和删除元素的时间复杂度？</p>
<p>对于插入：</p>
<ul>
<li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li>
<li>尾部插入：当 <code>ArrayList</code> 的容量<strong>未达到极限时</strong>，即不需要扩容时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li>
<li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li>
</ul>
<p>对于删除：</p>
<ul>
<li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li>
<li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li>
<li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li>
</ul>
</li>
<li><p>LinkedList 插入和删除元素的时间复杂度？</p>
<ul>
<li>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li>
<li>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li>
<li>指定位置插入&#x2F;删除：<strong>需要先移动到指定位置</strong>，再修改指定节点的指针完成插入&#x2F;删除，因此需要遍历平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li>
<li><strong>注意：ArrayList和LinkedList在指定位置插入&#x2F;删除元素时，时间复杂度虽然一样，但是消耗时间的具体内容不同：ArrayList是将时间消耗在将指定位置后所有元素向后移动一位上，但是其找到指定位置可以更具数组的特性使用O(1)的时间找到。LinkedList是将时间消耗在遍历找到指定位置上，只需要改变链表的前向和后向节点就可以，不需要大量移动指定位置后的所有元素。</strong></li>
</ul>
</li>
<li><p>ArrayList 与 LinkedList 区别?</p>
<ul>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，循环链表就是最后一个元素的next指针指向头元素，头元素的pre指针指向尾元素；JDK1.7 取消了循环。）</li>
<li>插入和删除是否受元素位置的影响：<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中<strong>第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</strong></li>
<li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，<strong>因为需要先移动到指定位置</strong>再插入和删除。</li>
</ul>
</li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
</li>
<li><p>LinkedList 为什么不能实现 RandomAccess 接口？</p>
<p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。<strong>由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，</strong>只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口。</p>
</li>
<li><p>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</p>
<ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于<strong>底层数据结构不同</strong>。<code>HashSet</code> 的底层数据结构是<strong>哈希表</strong>（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是<strong>链表和哈希表</strong>，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是<strong>红黑树</strong>，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
</li>
</ol>
<h3 id="Java集合常见面试题总结（下）"><a href="#Java集合常见面试题总结（下）" class="headerlink" title="Java集合常见面试题总结（下）"></a>Java集合常见面试题总结（下）</h3><ol>
<li>HashMap 和 Hashtable 的区别<ul>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍；<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。② 创建时如果给定了容量初始值，<code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）； <code>Hashtable</code> 会直接使用你给定的大小。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.youngj.top/2023/07/10/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" data-id="cljxynd0u0005awu91ftybqtm" data-title="" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/07/12/%E6%B5%81%E6%B0%B4%E8%B4%A6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          流水账
        
      </div>
    </a>
  
  
    <a href="/2023/07/09/20230709-%E4%B8%AA%E4%BA%BA/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">20230709-个人</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA/">个人</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%A5%E5%8F%B2%E4%B8%BA%E9%89%B4/">以史为鉴</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E6%B0%B4%E8%B4%A6/" rel="tag">流水账</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%B5%81%E6%B0%B4%E8%B4%A6/" style="font-size: 10px;">流水账</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/07/12/%E6%B5%81%E6%B0%B4%E8%B4%A6/">流水账</a>
          </li>
        
          <li>
            <a href="/2023/07/10/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/07/09/20230709-%E4%B8%AA%E4%BA%BA/">20230709-个人</a>
          </li>
        
          <li>
            <a href="/2023/07/06/%E6%9D%8E%E6%B8%8A%E4%B9%B0%E9%A9%AC/">李渊买马</a>
          </li>
        
          <li>
            <a href="/2023/07/04/%E6%9D%82%E8%B0%88-20230704/">杂谈-20230704</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 YoungJ<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>